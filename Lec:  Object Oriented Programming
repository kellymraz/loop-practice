Lec:  Object Oriented Programming

OOP is a programming paradigm based on the creation of objects

Objects can have properties-- regular properties and/or methods can be attached to objects

{ name : Bill}

Name is a property and Bill is a value

A method is a callable property

We can store a function as a value in a key : value
pair and keep the option to call it

myObj.toString(Bill)

Context-- what object are we looking at?  OOP allows us to change one object at a time.  Also OOP helps with naming... we don't want a bunch of global variables.  We can also use OOP to standardize the way our data looks.  

Two things we use a lot in OOP:
1. classes-- like a blueprint for your data structure-- the object will have these properties (ex. name, age, etc) and look a certain way.

May carry different values but the structure is the same. 

Ex.  we have an app and we're interested in cats.  We want to construct cats, so we will use 

CONSTRUCTOR FUNCTIONS 

var Cat (constructors are usually named with a capital letter to note they are a constructor).  We need to feed in some parameters so it can become a cat.

var Cat = function(name, color, smell, whiskers) {
	properties

	whiskers - true / false
	smell
	color
	name




this.name = name;
this.color = color;
this.smell = smell;
this.whiskers = whiskers;

this.sleep  = function() {
	console.log("This cat is sleeping");
}

this.eat    = function (This cat is eating)
	console.log("nom nom nom")
}








Above our constructor is defined (var Cat) and now we need to make a cat...

var blackCat = new Cat("Purrkins", "black", "bad", "true");

var tabbyCat = ("Paul", "orange",
 "good", "false")

console.log(blackCat);

Keyword 	THIS

THIS is an arbitrary object that lives in a scope created by a function.  Every scope has a this.

In Jq you use "this" to get the created DOM element.  With constructors, "this" refers to the instance that we are creating.  This refers to whichever object is currently being looked at-- above it is the blackCat.  "This" is immune to closure, so if you need pass it to another scope or function yu will need to set it to another variable or it will be over-ridden.  


What is going on under the hood?

var myFunc = function(firstName, lastName){
	
	var firstName =
	var lastName=

	return undefined


}

new myFunc()

when you use the NEW keyword with a function, the "this" becomes more valuable

When you use the "new" keyword, "this" will be returned by default.  

We can also attach methods to objects..

cats also sleep, eat and hunt. see above


Create a class of quotes with 2 properties:  the text of the quote and the author.  create a new instance of the quote class and store it in a variable.  Bonus-- have default values for text / author if none are passed into the function

First, define your constructor 

 var Quote = function(text, author) {

	this.text = text || "no text here";
  	this.author = author || "anonymous"

}


var greatQuote = new Quote("All you need is love", "Da Beatles")

var notSoGreatQuote = new Quote ()


Back to the cat class...

All objects in JS have what is called a PROTOTYPE
You will see it on the console log.  We say class but it is really a prototype.  Every object in JS is based on a prototype

If we inspect our cat constructor, it will show Proto:  

Eat and sleep are methods, but they are defined as properties on an object.  They are attached to each new cat, new individual object.  

You can also attach methods to a prototype.  

var myArr = []
var myArr = new Array

Attach the methods to the protypes to improve performance.  

We can change the sleep and eat methods to prototype functions.



Cat.prototype.sleep = function(){
	
	console.log("This " + this.color + " cat is sleeping. Zzzzzzzz");

}


blackCat.sleep()

because we call with . notation, the sleep method attached to the prototype takes on the value of "this"

WE have made sleep a method of the prototype, NOT a property of cat like whiskers, name, color.  

Usually methods live on the prototype and the properties live on the object.  Usually you will be using the prototype to contain methods.

Challenge:  Update the Quote class to include 2 methods

attach them to the prototype
Include countWords, which will return the # of words in your quote
	AND
create, which will return a new DOM element via jquery for the qyote

Quote.prototype.countWords = function(){
	return this.text.split(" ").length
}

Quote.prototype.create = function()

	var quoteEl = $("<div class=my-quote"></div>)
	quoteEl.text(this.text + " - " + this.author)

	return Quote.el


}

$("body").append ( greatQuote.create() )

var quoteEl is a virtual DOM element with text in it

We can create new or modify a property on an instance using prototype

ATTACH COMMON METHODS TO THE PROTOTYPE RATHER THAN ADD THEM AS PROPERTIES TO EVERY OBJECT IN AN ARRAY


















