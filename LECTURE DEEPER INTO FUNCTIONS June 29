LECTURE DEEPER INTO FUNCTIONS June 29

scope

a zone in memory where names are defined
we are now in the global scope

var foo = 10

if you define a function

var fullName = function(first,last){
	var fullName = first + " " last +
	return fullName

}

ALWAYS DESIGN VARIABLES WITH var (don't make them global with . notation, it will get too messy)
	
You can only access the var fullName inside the curly brackets / within
the same scope where it was created.  If we put console.log after the function }
nothing will happen, must be inside of the curly brackets.

Code outside of a function cannot see variables defined inside of a function,
but the function can see variables defined outside of itself

	Inside of the function, while it is running, we are in the 
	LEXICAL scope; only functions create their own scope
	in JS

var fullName = "Steve Stevenson";


var fullName = first + " " + last

JS looks up values of variable names in a certain order
First- looks in the current local scope, then the parent scope, then up
to the global scope.  LESSON:  USE UNIQUE NAMES FOR INNER AND OUTER FUNCTIONS

GARBAGE COLLECTION
Deletes a value that we have no reference to 

Look into garbage collection because it will keep the memory from getting full of variables that are really only temporary. 

Exception to garbage collection
 is called "closure"

 var counterConstructor = function(){
 	var start = 0;
 	var counter = function(){
 		console.log(start++)
 	}

 	return counter

 }

var myCounter = counterConstructor() 
myCounter() = counterConstructor)  ---> 1
myCounter  ---> 2
myCounter  ---> 3
myCounter  ---> 4
myCounter  ---> 5
var yourCounter = counterConstructor()  ----> 6 (wouldn't go back to 0, which is inside the function)

The myCounter function has closure over the start variable, in this case.

Every time you call this function it will count up (1, 2, 3 etc.).  The start variable above is start = 0

The start variable is necessary to the function.  The inner counter function has CLOSURE over the START VARIABLE, WHICH PREVENTS START FROM BEING GARBAGE COLLECTED.

Every time you call a function it creates a new, different scope with a different start variable.

























